# 2023-01-14
## `MPI_Scatterv`, `MPI_Gattherv` and `MPI_Allgatherv`
The common thread between these three (and perhaps more) collective
communication functions are the two buffers `sendcounts` and `displs` (see `man 3 MPI_Gatherv` or [view online](https://www.open-mpi.org/doc/v3.1/man3/MPI_Gatherv.3.php)).

I found myself writing code to construct these two buffers every
time for roughly equal distribution. Here is the convenience function.

```C
typedef struct
{
    int *sendcounts;
    int *displs;
} vparams_t;

int vparams_create(vparams_t *vp, int count, int nprocs)
{
    int *sendcounts = malloc(sizeof(int) * nprocs);
    check_mem(sendcounts);
    int *displs = malloc(sizeof(int) * nprocs);
    check_mem(displs);
    int quot = count / nprocs;
    int rem = count % nprocs;
    int running_displ = 0;
    for (int i = 0; i < nprocs; i++)
    {
        int sc = quot;
        if (i < rem)
            sc++;
        sendcounts[i] = sc;
        displs[i] = running_displ;
        running_displ += sc;
    }

    vp->sendcounts = sendcounts;
    vp->displs = displs;
    return 0;
error:
    return 1;
}
```

## Presentation on Error Handling in C
Came across these nice [slides](https://resources.sei.cmu.edu/asset_files/Presentation/2016_017_101_484207.pdf).

# 2023-01-15
## MPI - Basics of Creating Communicators and Process Topologies 
As it turns out, you do not always have to fiddle around with index calculations to calculate the ranks of
your neighbouring process(es). `MPI_Cart_create` and friends can handle some of that for you.

Here is a minimum working example (MWE) for creating a 1D torus.
```C
#include <stdio.h>
#include <stdlib.h>
#include <mpi.h>
#include <stdbool.h>

int main(int argc, char *argv[])
{
    int rank, nprocs;
    MPI_Comm commring;
    MPI_Init(&argc, &argv);
    MPI_Comm_size(MPI_COMM_WORLD, &nprocs);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);

    int const period = 1, ndims = nprocs;
    bool reorder = true;
    MPI_Cart_create(MPI_COMM_WORLD, 1, &ndims, &period, reorder, &commring);
    int left, right;
    MPI_Cart_shift(commring, 0, 1, &left, &right);

    fprintf(stderr, "rank %d: left neighbour: %d, right neighbour: %d\n", rank, left, right);
    MPI_Finalize();
    return 0;
}
```
Please don't enable too many warning flags because we're ignoring a lot of return values. Higher dimensions are possible, but am yet
to try it. Consider consulting the [man pages](https://www.open-mpi.org/doc/v4.1/man3/MPI_Cart_create.3.php) `man 3 MPI_Cart_create`.

This month I am doing a course that has an MPI assignment. Hence the entries on MPI.

## Domain Decomposition Resources
A relatively compact summary of Galerkin approximations, Sobolev spaces, and other preconditioning
methods is given in the appendices of Toselli and Widlund's book. I should probably consolidate all info related to my thesis
in a separate place

# 2023-01-16
## On Focus and Crises
I started reading "Life on a Knife's Edge" by Dr Rahul Jandial. In chapter two, "Performance", Dr Jandial
shares some information regarding staying calm and focused in stressful situations. The original text is
an excellent account and what follows is merely a wattered down summary for my own reference later.

**Alarm Overload**: More alarms are perceived than can be addressed.

E.g. during the partial core meltdown at the Three Mile Island nuclear power plant, operators were disoriented by
all the alarms and didn't know which alarms were the most pressing and which could be ignored.

To respond quickly and effectively in a crisis, we need a way to bring order to the external alarms, to _find focus by ignoring
emotional distractors_. When you are being inundated with stimuli, a cluster of neurons known as the basal glandia actively filter
out what is deemed unimportant.

Note the exact phrasing here -- it does not emphasise the important stimulus, but filters out the unimportant.
Neural activity is lower in experts because they don't dial up the focus, but dial down the distraction and stress.
The ability to be vigilant is built-in, but the ability to ignore must be cultivated.

### Breathing Patterns, Brain Activity and Staying in Control
Controlling your breathing is the most powerful weapon you have to strengthen your emotional regulation and improve your performance.
Don't just use it as safety valve in times of crisis, but train it regularly. Dr Jandial noticed that other experienced surgeons used
tape to seal their surgical masks to the bridge of their nose in prevent fogging the magnification lenses worn by them. Under pressure,
your breathing becomes fast and heavy. Dr Jandial does not use tape because when his FOV fogs up, he knows that he is doing something wrong
and needs to control his breath.

The adaptive state that we tend to slip into during stressful situations is one of hyperventilation; the brain readies the lungs and
diaphragm. Meditative breathing can moderate the electrical activity in the brain; your breathing patterns can steer your brain towards
both breathing and calm.

"I used the time to steady my breathing. In situations like this, I don't breathe more deeply, I breathe more slowly.
Three seconds in; three seconds out. No sudden inhalation with mouth agape. I find it easier to pace my breathing by
inhaling and exhaling through my nose."

## (TODO) Customizing Broadcast in Julia
High level overview. Broadcasting something that subtypes `AbstractArray` and implements its interface properly is somewhat
easy. Other types can be non-trivial. This is my own understanding and could be incorrect. Once I have a working broadcast
for a non-array type, I will put it in another daybook entry.

Relevant types and methods.
- `Broadcast.BroadcastStyle`: An empty struct specialized for your type. Dispatch on relevant binary methods to combine styles into destination styles
- `Broadcast.Broadcasted`: A tree-like container for lazily evaluating a compound broadcasted expression 
- `Broadcast.instantiate`: Takes a `Broadcast.Broadcasted` and figues out the final axes type and value
- `Broadcast.materialize`: Performs the broadcast operation
- `Base.copyto!(dest, ::Broadcast.Broadcasted)`: Method called by `materialize` to perform calculations and store results in destination style

# 2023-01-17
## Iterative Solvers
I should probably know the following Krylov subspace solvers like the back of my hand, and probably even be
able to hammer out an implementations in Julia for using the `AbstractVectors` and `AbstractMatrix`
interfaces/abstract types/concepts/whatever on a whim. Every time I need anything related to iterative solvers,
I find myself studying them again. What is this? Ultra-mega-early onset of dementia? Do I have to make Anki cards
for them?
- Conjugate Gradient
- Generalized Minimal RESidual (GMRES)
Probably some more as well. See chapter 3 of "An Introduction to Domain Decomposition Methods" by Dolean, Jolivet and Nataf.
See 
- 
